<html>
<head>
    <title>Edit Preset: {{ preset.name }}</title>
    <link rel="stylesheet" href="/static/review.css?{{ static_version }}">
</head>
<body>
    <p><a href="{% match back_url %}{% when Some with (url) %}{{ url }}{% when None %}/presets{% endmatch %}">&larr; Back</a></p>
    <h1>Edit Preset: <span id="preset-name-display">{{ preset.name }}</span></h1>

    <div class="section">
        <div class="field-group">
            <div class="field">
                <span>Preset name</span>
                <input type="text" id="preset-name" value="{{ preset.name }}" size="30">
            </div>
            <div class="field field-end">
                <button onclick="savePreset()" class="primary">Save</button>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Rules</h2>
        <div class="add-rule-form" id="add-rule-form"></div>
        <div id="rules-container"></div>
    </div>

    <div class="section">
        <h2>Built-in Rules</h2>
        <div id="builtin-rules"></div>
        <div class="builtin-save-wrap">
            <button id="builtin-save-btn" class="primary small" onclick="saveBuiltins()" disabled>Save built-in rules</button>
        </div>
    </div>


<div hidden id="initial-rules-data" data-json="{{ preset.rules }}"></div>
<div hidden id="initial-builtins-data" data-json="{{ preset.builtin_rules }}"></div>
<script src="/static/review-utils.js?{{ static_version }}"></script>
<script>
const PRESET_ID = {{ preset.id }};
let INITIAL_RULES = [];
let INITIAL_BUILTINS = [];
try {
    INITIAL_RULES = JSON.parse(document.getElementById("initial-rules-data").dataset.json);
    INITIAL_BUILTINS = JSON.parse(document.getElementById("initial-builtins-data").dataset.json);
} catch(e) {
    showToast("Failed to parse initial data: " + e.message);
}
const CURRENT_USERNAME = "{{ current_username }}";

let gamesData = [];
const gameToApworld = {};
const optionsCache = {};

async function loadGames() {
    try {
        const resp = await fetch("/api/games");
        if (!resp.ok) { showToast("Failed to load games list"); return; }
        gamesData = await resp.json();
        for (const g of gamesData) gameToApworld[g.game_name] = g.apworld_name;
    } catch(e) { showToast("Failed to load games list: " + e.message); }
}

async function getOptionsForGame(gameName) {
    const apworld = gameToApworld[gameName];
    if (!apworld) return [];
    if (optionsCache[apworld]) return optionsCache[apworld];
    try {
        const resp = await fetch(`/api/games/${encodeURIComponent(apworld)}/options`);
        if (!resp.ok) return [];
        const data = await resp.json();
        optionsCache[apworld] = data;
        return data;
    } catch(e) { return []; }
}

function ensureDatalist(id, values) {
    let dl = document.getElementById(id);
    if (dl) dl.remove();
    if (!values || values.length === 0) return;
    dl = h("datalist", { id }, ...values.map(v => h("option", { value: v })));
    document.body.appendChild(dl);
}

function formatEditTimestamp() {
    return new Date().toISOString().replace("T", " ").slice(0, 16) + " UTC";
}

function editInfoText(name, date) {
    if (!name) return null;
    return `Last edited by ${name}${date ? ` on ${date}` : ''}`;
}

const CHECK_TYPES = [
    ["truthy", "Truthy"], ["not_truthy", "Not Truthy"],
    ["equals", "Equals"], ["not_equals", "Not Equals"],
    ["greater_than", "Greater Than"], ["less_than", "Less Than"],
    ["range", "Range"], ["regex", "Regex"], ["contains", "Contains"],
    ["exists", "Exists"], ["not_exists", "Not Exists"],
];

const PRED_TYPES = [["check", "Check"], ["and", "AND"], ["or", "OR"], ["not", "NOT"]];
const SEVERITY_TYPES = [["error", "Error"], ["warning", "Warning"], ["info", "Info"]];

class PredicateBlock {
    constructor(data, { onDirty, getGame }) {
        this.onDirty = onDirty;
        this.getGame = getGame;

        this.el = document.createElement("div");
        this.el.className = "predicate-block";
        this.el._pred = this;

        this.typeSelect = selectEl("pred-type", PRED_TYPES, (data && data.type) || "check");
        let prevType = this.typeSelect.value;
        this.typeSelect.addEventListener("focus", () => { prevType = this.typeSelect.value; });
        this.typeSelect.addEventListener("change", () => {
            this._onTypeChange(prevType);
            prevType = this.typeSelect.value;
        });

        const removeBtn = h("button", { className: "danger small pred-remove", onclick: () => { this.el.remove(); this.onDirty(); } }, "x");

        this.body = document.createElement("div");
        this.body.className = "pred-body";

        this.el.append(
            h("div", { className: "predicate-header" }, this.typeSelect, removeBtn),
            this.body,
        );
        this._renderBody(data);
    }

    _onTypeChange(oldType) {
        const newType = this.typeSelect.value;
        let existing = null;
        if (oldType && oldType !== newType) {
            this.typeSelect.value = oldType;
            existing = this.gather();
            this.typeSelect.value = newType;
        }

        const isGroup = (t) => t === "and" || t === "or";
        if (existing && isGroup(newType) && isGroup(oldType)) {
            this._renderBody({ type: newType, predicates: existing.predicates });
        } else if (existing && isGroup(newType)) {
            this._renderBody({ type: newType, predicates: [existing] });
        } else if (existing && newType === "not") {
            this._renderBody({ type: "not", predicate: existing });
        } else {
            this._renderBody();
        }
        this.onDirty();
    }

    _renderBody(data) {
        this.body.replaceChildren();
        const type = this.typeSelect.value;
        if (type === "check") {
            this._renderCheck(data);
        } else if (type === "and" || type === "or") {
            this._renderGroup(data);
        } else if (type === "not") {
            this._renderNot(data);
        }
    }

    _renderCheck(data) {
        const d = data || {};
        const pathInput = h("input", { type: "text", className: "check-path", value: d.path || "", size: "20" });
        const checkTypeSel = selectEl("check-type", CHECK_TYPES, d.check?.type);
        const params = h("span", { className: "check-params" });

        this.body.append(h("div", { className: "field-group" },
            field("Path", pathInput),
            field("Check", checkTypeSel),
            params,
        ));

        checkTypeSel.addEventListener("change", () => this._renderCheckParams(checkTypeSel));
        pathInput.addEventListener("focus", () => this._autocompletePathFor(pathInput));

        if (d.check) {
            this._renderCheckParams(checkTypeSel, d.check);
        }
    }

    _renderCheckParams(sel, data) {
        const params = this.body.querySelector(".check-params");
        const type = sel.value;
        params.replaceChildren();

        if (type === "equals" || type === "not_equals" || type === "contains") {
            const inp = h("input", { type: "text", className: "check-value", value: (data && data.value) || "", size: "15" });
            inp.addEventListener("focus", (e) => this._autocompleteValueFor(e.target));
            params.append(field("Value", inp));
        } else if (type === "greater_than" || type === "less_than") {
            params.append(field("Value", h("input", { type: "number", className: "check-value-num", value: (data && data.value) || 0 })));
        } else if (type === "range") {
            params.append(
                field("Min", h("input", { type: "number", className: "check-min", value: (data && data.min) || 0 })),
                field("Max", h("input", { type: "number", className: "check-max", value: (data && data.max) || 0 })),
            );
        } else if (type === "regex") {
            params.append(field("Pattern", h("input", { type: "text", className: "check-pattern", value: (data && data.pattern) || "", size: "20" })));
        }
    }

    async _autocompletePathFor(input) {
        const game = this.getGame();
        if (!game) return;
        const options = await getOptionsForGame(game);
        input.setAttribute("list", "dl-path");
        ensureDatalist("dl-path", options.map(o => o.name));
    }

    async _autocompleteValueFor(input) {
        const game = this.getGame();
        if (!game) return;
        const options = await getOptionsForGame(game);
        const pathInput = this.body.querySelector(".check-path");
        if (!pathInput) return;
        const optDef = options.find(o => o.name === pathInput.value);
        if (!optDef) return;
        const values = optDef.choices || optDef.suggestions || optDef.valid_keys;
        input.setAttribute("list", "dl-value");
        ensureDatalist("dl-value", values);
    }

    _renderGroup(data) {
        const childrenEl = h("div", { className: "pred-children" });
        const addBtn = h("button", { onclick: () => {
            childrenEl.appendChild(new PredicateBlock(null, {
                onDirty: this.onDirty, getGame: this.getGame,
            }).el);
            this.onDirty();
        }}, "+ Add");
        this.body.append(childrenEl, addBtn);

        if (data && data.predicates) {
            for (const p of data.predicates) {
                const child = new PredicateBlock(p, {
                    onDirty: this.onDirty, getGame: this.getGame,
                });
                childrenEl.appendChild(child.el);
            }
        }
    }

    _renderNot(data) {
        const inner = h("div", { className: "pred-inner" });
        inner.appendChild(new PredicateBlock(
            data && data.predicate ? data.predicate : null,
            { onDirty: this.onDirty, getGame: this.getGame },
        ).el);
        this.body.appendChild(inner);
    }

    gather() {
        const type = this.typeSelect.value;
        if (type === "check") {
            const path = this.body.querySelector(".check-path").value;
            const checkType = this.body.querySelector(".check-type").value;
            const check = { type: checkType };
            if (checkType === "equals" || checkType === "not_equals" || checkType === "contains") {
                check.value = this.body.querySelector(".check-value").value;
            } else if (checkType === "greater_than" || checkType === "less_than") {
                check.value = parseInt(this.body.querySelector(".check-value-num").value) || 0;
            } else if (checkType === "range") {
                check.min = parseInt(this.body.querySelector(".check-min").value) || 0;
                check.max = parseInt(this.body.querySelector(".check-max").value) || 0;
            } else if (checkType === "regex") {
                check.pattern = this.body.querySelector(".check-pattern").value;
            }
            return { type: "check", path, check };
        } else if (type === "and" || type === "or") {
            const children = this.body.querySelectorAll(":scope > .pred-children > .predicate-block");
            return { type, predicates: Array.from(children).map(el => el._pred.gather()) };
        } else if (type === "not") {
            const child = this.body.querySelector(":scope > .pred-inner > .predicate-block");
            return { type: "not", predicate: child ? child._pred.gather() : null };
        }
    }

    static validate(pred) {
        if (!pred) return null;
        if (pred.type === "check") {
            if (!pred.path || !pred.path.trim()) return "Check predicate has an empty path";
        } else if (pred.type === "and" || pred.type === "or") {
            for (const p of (pred.predicates || [])) {
                const err = PredicateBlock.validate(p);
                if (err) return err;
            }
        } else if (pred.type === "not") {
            return PredicateBlock.validate(pred.predicate);
        }
        return null;
    }
}

function buildRuleForm(container, { name, game, severity, whenData, thenData, predCallbacks }) {
    container.replaceChildren(
        h("div", { className: "field-group" },
            field("Name", h("input", { type: "text", className: "rule-name", value: name || "", placeholder: "Rule name", size: "25" })),
            field("Game", h("input", { type: "text", className: "rule-game", value: game || "", placeholder: "(all games)", size: "15", list: "dl-games" })),
            field("Severity", selectEl("rule-severity", SEVERITY_TYPES, severity || "error")),
        ),
    );

    for (const [which, label, hint, btnText, data] of [
        ["when", "When", "(optional condition)", "+ Set Condition", whenData],
        ["then", "Then", "(alerts when met)", "+ Set Check", thenData],
    ]) {
        const cont = h("div", { className: `${which}-container` });
        const btn = h("button", { className: "small" }, btnText);
        btn.onclick = () => {
            if (cont.querySelector(".predicate-block")) { showToast("Already set. Remove it first or use AND/OR."); return; }
            const pred = new PredicateBlock(null, predCallbacks);
            cont.appendChild(pred.el);
            if (predCallbacks.onDirty) predCallbacks.onDirty();
        };

        container.append(h("div", { className: "rule-section" },
            h("div", { className: "rule-section-header" },
                h("strong", null, label), " ", h("span", { className: "hint" }, hint), btn,
            ),
            cont,
        ));

        if (data) {
            cont.appendChild(new PredicateBlock(data, predCallbacks).el);
        }
    }
}

class RuleEditor {
    constructor({ serverId, name, game, severity, when, then, lastEditedByName, lastEditedAt, dirty, onClone, onDelete }) {
        this.serverId = serverId;
        this.lastEditedByName = lastEditedByName || null;
        this.lastEditedAt = lastEditedAt || null;
        this.dirty = dirty || false;
        this.open = false;
        this.onClone = onClone || (() => {});
        this.onDelete = onDelete || (() => {});

        this.el = document.createElement("div");
        this._build({ name, game, severity, when, then });
    }

    _build({ name, game, severity, when, then }) {
        this.el.replaceChildren();

        this.row = document.createElement("div");
        this.row.className = "rule-row";
        this._buildRow({ name, severity });

        this.editor = document.createElement("div");
        this.editor.className = "rule-editor" + (this.open ? " open" : "");
        this._buildEditor({ name, game, severity, when, then });

        this.el.append(this.row, this.editor);
    }

    _buildRow({ name, severity }) {
        this.row.replaceChildren(
            h("span", { className: "unsaved-badge", style: "display:none" }, "unsaved"),
            h("span", { className: "rule-name-label", title: editInfoText(this.lastEditedByName, this.lastEditedAt) }, name),
            h("span", { className: `severity-badge ${severity}` }, severity),
            h("span", { className: "rule-actions" },
                h("button", { className: "small", onclick: (e) => { e.stopPropagation(); this.onClone(); } }, "Clone"),
                h("button", { className: "small danger", onclick: (e) => { e.stopPropagation(); this.onDelete(); } }, "x"),
            ),
        );
        this.row.onclick = () => this.toggle();
    }

    _buildEditor({ name, game, severity, when, then }) {
        const predCallbacks = {
            onDirty: () => this.markDirty(),
            getGame: () => this.editor.querySelector(".rule-game").value.trim() || null,
        };
        buildRuleForm(this.editor, {
            name, game, severity,
            whenData: when, thenData: then,
            predCallbacks,
        });

        const nameInput = this.editor.querySelector(".rule-name");
        const gameInput = this.editor.querySelector(".rule-game");
        const sevSelect = this.editor.querySelector(".rule-severity");

        nameInput.addEventListener("change", () => this._updateRow());
        gameInput.addEventListener("change", () => { this._updateRow(); renderAll(); });
        sevSelect.addEventListener("change", () => this._updateRow());

        this.saveBtn = h("button", {
            className: "primary small",
            disabled: !this.dirty,
            onclick: (e) => { e.stopPropagation(); this.save(); },
        }, "Save rule");

        const footer = h("div", { className: "rule-footer" }, this.saveBtn);
        const info = editInfoText(this.lastEditedByName, this.lastEditedAt);
        if (info) footer.append(h("span", { className: "edit-info" }, info));

        this.editor.append(footer);
        this.editor.addEventListener("input", () => this.markDirty());
        this.editor.addEventListener("change", () => this.markDirty());
    }

    _updateRow() {
        const name = this.editor.querySelector(".rule-name").value;
        const severity = this.editor.querySelector(".rule-severity").value;
        const label = this.row.querySelector(".rule-name-label");
        if (label) label.textContent = name;
        const badge = this.row.querySelector(".severity-badge");
        if (badge) { badge.className = `severity-badge ${severity}`; badge.textContent = severity; }
    }

    toggle() {
        this.open = !this.open;
        this.editor.classList.toggle("open", this.open);
    }

    markDirty() {
        if (this.dirty) return;
        this.dirty = true;
        if (this.saveBtn) this.saveBtn.disabled = false;
        const badge = this.row.querySelector(".unsaved-badge");
        if (badge) badge.style.display = "";
    }

    gather() {
        const name = this.editor.querySelector(".rule-name").value;
        const game = this.editor.querySelector(".rule-game").value || null;
        const severity = this.editor.querySelector(".rule-severity").value;
        const whenEl = this.editor.querySelector(".when-container > .predicate-block");
        const thenEl = this.editor.querySelector(".then-container > .predicate-block");
        const when = whenEl ? whenEl._pred.gather() : null;
        const then_ = thenEl ? thenEl._pred.gather() : null;
        return {
            name, game, severity, when,
            then: then_ || { type: "check", path: "", check: { type: "truthy" } },
        };
    }

    async save() {
        if (!this.serverId) return;
        const ruleData = this.gather();
        const err = PredicateBlock.validate(ruleData.when) || PredicateBlock.validate(ruleData.then);
        if (err) { showToast(err); return; }

        const position = editors.indexOf(this);
        const resp = await fetch(`/api/presets/${PRESET_ID}/rules/${this.serverId}`, {
            method: "PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ rule: ruleData, position }),
        });
        if (!resp.ok) { showToast("Failed to save rule: " + await resp.text()); return; }

        this.dirty = false;
        this.lastEditedByName = CURRENT_USERNAME;
        this.lastEditedAt = formatEditTimestamp();
        this._build({
            name: ruleData.name, game: ruleData.game, severity: ruleData.severity,
            when: ruleData.when, then: ruleData.then,
        });
    }

}

let editors = [];

const openGroups = new Set();

function renderAll() {
    const container = document.getElementById("rules-container");
    container.replaceChildren();

    const grouped = {};
    const globalKey = "__all_games__";

    for (const ed of editors) {
        const key = ed.editor.querySelector(".rule-game").value.trim() || globalKey;
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(ed);
    }

    const keys = Object.keys(grouped).sort((a, b) => {
        if (a === globalKey) return -1;
        if (b === globalKey) return 1;
        return a.localeCompare(b);
    });

    for (const key of keys) {
        const label = key === globalKey ? "All Games" : key;
        const groupEditors = grouped[key];
        const isOpen = openGroups.has(key);

        const group = h("div", { className: "game-group" + (isOpen ? " open" : "") });

        const header = h("div", { className: "game-group-header", onclick: () => {
            group.classList.toggle("open");
            if (group.classList.contains("open")) openGroups.add(key);
            else openGroups.delete(key);
        }},
            h("span", { className: "toggle" }),
            h("span", { className: "game-label" }, label),
            h("span", { className: "rule-count" }, `${groupEditors.length} rule${groupEditors.length !== 1 ? 's' : ''}`),
        );

        const body = h("div", { className: "game-group-body" });
        for (const ed of groupEditors) body.appendChild(ed.el);
        group.append(header, body);

        container.appendChild(group);
    }
}

function initAddRuleForm() {
    const form = document.getElementById("add-rule-form");
    const gameGetter = () => form.querySelector(".rule-game").value.trim() || null;
    buildRuleForm(form, {
        name: "", game: null, severity: "error",
        whenData: null, thenData: null,
        predCallbacks: { onDirty: () => {}, getGame: gameGetter },
    });
    form.append(h("div", { className: "field field-end" },
        h("button", { className: "accent", onclick: addNewRule }, "+ Add Rule"),
    ));
}

async function addNewRule() {
    const form = document.getElementById("add-rule-form");
    const name = form.querySelector(".rule-name").value.trim() || "New Rule";
    const game = form.querySelector(".rule-game").value.trim() || null;
    const severity = form.querySelector(".rule-severity").value;

    const whenEl = form.querySelector(".when-container > .predicate-block");
    const thenEl = form.querySelector(".then-container > .predicate-block");
    const whenData = whenEl ? whenEl._pred.gather() : null;
    const thenData = thenEl ? thenEl._pred.gather() : null;
    const ruleData = { name, game, severity, when: whenData, then: thenData || { type: "check", path: "", check: { type: "truthy" } } };

    const err = PredicateBlock.validate(ruleData.when) || PredicateBlock.validate(ruleData.then);
    if (err) { showToast(err); return; }

    const resp = await fetch(`/api/presets/${PRESET_ID}/rules`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ rule: ruleData, position: editors.length }),
    });
    if (!resp.ok) { showToast("Failed to create rule: " + await resp.text()); return; }
    const created = await resp.json();

    const ed = newEditor({
        serverId: created.id, name, game, severity,
        when: whenData, then: ruleData.then,
        lastEditedByName: CURRENT_USERNAME,
        lastEditedAt: formatEditTimestamp(),
    });
    editors.push(ed);

    openGroups.add(game || "__all_games__");
    initAddRuleForm();
    renderAll();
    ed.toggle();
}

function deleteEditor(ed) {
    const name = ed.row.querySelector(".rule-name-label").textContent;
    confirmDelete(name, async () => {
        if (ed.serverId) {
            const resp = await fetch(`/api/presets/${PRESET_ID}/rules/${ed.serverId}`, { method: "DELETE" });
            if (!resp.ok) { showToast("Failed to delete rule: " + await resp.text()); return; }
        }
        editors = editors.filter(e => e !== ed);
        renderAll();
    });
}

async function cloneEditor(original) {
    const data = original.gather();
    const idx = editors.indexOf(original);

    const resp = await fetch(`/api/presets/${PRESET_ID}/rules`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ rule: data, position: idx + 1 }),
    });
    if (!resp.ok) { showToast("Failed to clone rule: " + await resp.text()); return; }
    const created = await resp.json();

    const ed = newEditor({
        serverId: created.id,
        name: data.name + " (copy)",
        game: data.game,
        severity: data.severity,
        when: data.when ? JSON.parse(JSON.stringify(data.when)) : null,
        then: data.then ? JSON.parse(JSON.stringify(data.then)) : null,
    });
    editors.splice(idx + 1, 0, ed);
    renderAll();
    ed.toggle();
}

function newEditor(opts) {
    const ed = new RuleEditor({
        ...opts,
        onClone: () => cloneEditor(ed),
        onDelete: () => deleteEditor(ed),
    });
    return ed;
}

function loadRulesFromJSON(jsonRules) {
    editors = [];
    for (const r of jsonRules) {
        editors.push(newEditor({
            serverId: r.id,
            name: r.rule.name,
            game: r.rule.game,
            severity: r.rule.severity,
            when: r.rule.when,
            then: r.rule.then,
            lastEditedByName: r.last_edited_by_name || null,
            lastEditedAt: r.last_edited_at || null,
        }));
    }
    renderAll();
}

async function savePreset() {
    const name = document.getElementById("preset-name").value.trim();
    if (!name) { showToast("Name is required"); return; }

    const resp = await fetch(`/api/presets/${PRESET_ID}`, {
        method: "PUT",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ name }),
    });
    if (!resp.ok) { showToast("Failed to save: " + await resp.text()); return; }

    document.getElementById("preset-name-display").textContent = name;
}

function gatherBuiltins() {
    const ids = [];
    for (const cb of document.querySelectorAll("#builtin-rules input[type=checkbox]:checked")) {
        ids.push(cb.dataset.id);
    }
    return ids;
}

async function saveBuiltins() {
    const resp = await fetch(`/api/presets/${PRESET_ID}`, {
        method: "PUT",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ builtin_rules: gatherBuiltins() }),
    });
    if (!resp.ok) { showToast("Failed to save: " + await resp.text()); return; }

    document.getElementById("builtin-save-btn").disabled = true;
}

async function loadBuiltinRulesList() {
    const resp = await fetch("/api/builtin_rules");
    if (!resp.ok) return;
    const builtinRules = await resp.json();
    const container = document.getElementById("builtin-rules");
    container.replaceChildren();
    for (const r of builtinRules) {
        const cb = h("input", { type: "checkbox", "data-id": r.id, checked: INITIAL_BUILTINS.includes(r.id) });
        container.append(h("div", { className: "builtin-toggle" },
            h("label", null, cb, " ", h("strong", null, r.name), " - ", r.description),
        ));
    }
    container.addEventListener("change", () => {
        document.getElementById("builtin-save-btn").disabled = false;
    });
}

loadGames().then(() => {
    ensureDatalist("dl-games", gamesData.map(g => g.game_name));
    loadBuiltinRulesList();
    loadRulesFromJSON(INITIAL_RULES);
    initAddRuleForm();
});
</script>
</body>
</html>
