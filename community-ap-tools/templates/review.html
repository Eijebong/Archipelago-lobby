<html>
<head>
    <title>YAML Review - {{ room_name }}</title>
    <link rel="stylesheet" href="/static/review.css?{{ static_version }}">
    <link rel="stylesheet" href="/static/contrib/highlight.js/monokai.min.css?{{ static_version }}">
    <script src="/static/contrib/highlight.js/highlight.min.js?{{ static_version }}" defer></script>
    <script src="/static/contrib/highlight.js/yaml.min.js?{{ static_version }}" defer></script>
</head>
<body>
    <h1>YAML Review: {{ room_name }}</h1>

    <div class="section">
        <h2>Preset</h2>
        <div class="inline-form">
            <select id="preset-select" onchange="onPresetChange()">
                <option value="">-- No preset --</option>
            </select>
            <button id="edit-preset-btn" class="hidden" onclick="window.location.href=this.dataset.href">Edit preset</button>
        </div>
    </div>

    <div class="section" id="results-area">
        <div class="inline-form" style="margin-bottom:0.5em"><h2 style="margin:0">Results</h2><select id="game-filter" class="hidden" onchange="gameFilter = this.value; applyFilters()"><option value="">All games</option></select><input type="text" id="rule-filter" class="hidden" list="rule-filter-list" placeholder="Filter by rule..." oninput="ruleFilter = this.value; applyFilters()"><datalist id="rule-filter-list"></datalist><select id="status-filter" class="hidden" onchange="statusFilter = this.value; applyFilters()"><option value="">All statuses</option></select></div>
        <div id="results-content">
            <p class="loading">Select a preset and evaluate, or wait for auto-evaluation...</p>
        </div>
    </div>

    <dialog id="yaml-modal" onclick="if (event.target === this) hideYamlModal()">
        <div class="modal-body" id="yaml-modal-content"></div>
        <div class="button-container" id="yaml-modal-buttons"></div>
    </dialog>

<script src="/static/review-utils.js?{{ static_version }}"></script>
<script>
const ROOM_ID = "{{ room_id }}";
const LOBBY_ROOT_URL = "{{ lobby_root_url }}".replace(/\/$/, "");
const ASSIGNED_PRESET_ID = {% match assigned_preset_id %}{% when Some with (id) %}{{ id }}{% when None %}null{% endmatch %};
const IS_LOCKED = {{ is_locked }};

const CHECK_LABELS = {
    truthy: "is truthy", not_truthy: "is not truthy", equals: "equals", not_equals: "does not equal",
    greater_than: ">", less_than: "<", range: "between",
    regex: "matches", contains: "contains", count: "count",
    exists: "exists", not_exists: "does not exist",
};

const STATUS_TYPES = [["unreviewed", "Unreviewed"], ["reported", "Reported"], ["nok", "NOK"], ["ok", "OK"]];

const SORT_COLUMNS = [
    ["player", "Player"], ["discord", "Discord"], ["game", "Game"],
    ["issues", "Issues"], ["status", "Status"], ["created", "Created"],
];

let lastEvalData = null;
let reviewStatuses = {};
let sortColumn = "status";
let sortAsc = true;
let gameFilter = "";
let ruleFilter = "";
let statusFilter = "";
let currentModalYamlId = null;
let yamlDetailCache = {};

async function refreshPresetList() {
    const resp = await fetch("/api/presets");
    if (!resp.ok) { showToast("Failed to load presets"); return; }
    const presets = await resp.json();
    const sel = document.getElementById("preset-select");
    sel.replaceChildren(
        h("option", { value: "" }, "-- No preset --"),
        ...presets.map(p => h("option", { value: p.id }, p.name)),
    );
    if (ASSIGNED_PRESET_ID) {
        sel.value = ASSIGNED_PRESET_ID;
    }
    updateEditLink();
}

function updateEditLink() {
    const sel = document.getElementById("preset-select");
    const btn = document.getElementById("edit-preset-btn");
    const presetId = parseInt(sel.value);
    if (presetId) {
        btn.dataset.href = `/presets/${presetId}?from_room=${ROOM_ID}`;
        btn.classList.remove("hidden");
    } else {
        btn.classList.add("hidden");
    }
}

async function onPresetChange() {
    const sel = document.getElementById("preset-select");
    const presetId = parseInt(sel.value);
    updateEditLink();

    if (!presetId) {
        await fetch(`/api/room/${ROOM_ID}/preset`, { method: "DELETE" });
        document.getElementById("results-content").replaceChildren(h("p", null, "No preset assigned."));
        lastEvalData = null;
        return;
    }

    const resp = await fetch(`/api/room/${ROOM_ID}/preset`, {
        method: "PUT",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ preset_id: presetId }),
    });
    if (!resp.ok) { showToast("Failed to assign preset"); return; }
    runEvaluation();
}

async function runEvaluation() {
    const sel = document.getElementById("preset-select");
    const presetId = parseInt(sel.value);
    const content = document.getElementById("results-content");
    if (!presetId) {
        content.replaceChildren(h("p", null, "No preset assigned."));
        return;
    }

    content.replaceChildren(h("p", { className: "loading" }, "Evaluating..."));

    const resp = await fetch(`/api/review/${ROOM_ID}/evaluate`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ preset_id: presetId }),
    });

    if (!resp.ok) {
        content.replaceChildren(h("p", { className: "error-text" }, "Error: " + await resp.text()));
        return;
    }

    const data = await resp.json();
    lastEvalData = data;
    await fetchReviewStatuses();
    renderResults(data);
}

function formatDate(s) {
    if (!s) return "";
    const d = new Date(s);
    if (isNaN(d)) return s;
    return d.toLocaleDateString() + " " + d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

function renderCheck(path, check) {
    const op = CHECK_LABELS[check.type] || check.type;
    const v = (s) => h("span", { className: "pred-value" }, String(s));
    const frag = document.createDocumentFragment();
    frag.append(h("span", { className: "pred-path" }, path), " ", h("span", { className: "pred-op" }, op));

    switch (check.type) {
        case "equals": case "not_equals": case "greater_than": case "less_than":
        case "regex": case "contains": {
            const val = check.type === "regex" ? '/' + check.pattern + '/' : String(check.value);
            frag.append(" ", v(val));
            break;
        }
        case "range":
            frag.append(" ", v(check.min), " ", h("span", { className: "pred-op" }, "and"), " ", v(check.max));
            break;
        case "count": {
            const innerOp = CHECK_LABELS[check.check.type] || check.check.type;
            frag.append(" ", h("span", { className: "pred-op" }, innerOp));
            if (check.check.type === "range") {
                frag.append(" ", v(check.check.min), " ", h("span", { className: "pred-op" }, "and"), " ", v(check.check.max));
            } else if (check.check.value !== undefined) {
                frag.append(" ", v(String(check.check.value)));
            }
            break;
        }
    }
    return frag;
}

function renderPredicate(pred) {
    switch (pred.type) {
        case "check":
            return renderCheck(pred.path, pred.check);
        case "and":
        case "or": {
            const frag = document.createDocumentFragment();
            pred.predicates.forEach((p, i) => {
                if (i > 0) frag.append(document.createElement("br"), h("span", { className: "pred-logic" }, pred.type.toUpperCase() + " "));
                frag.append(renderPredicate(p));
            });
            return frag;
        }
        case "at_least": {
            const frag = document.createDocumentFragment();
            frag.append(h("span", { className: "pred-logic" }, `AT LEAST ${pred.count} OF `));
            pred.predicates.forEach((p, i) => {
                if (i > 0) frag.append(document.createElement("br"), h("span", { className: "pred-logic" }, ", "));
                frag.append(renderPredicate(p));
            });
            return frag;
        }
        case "not": {
            const frag = document.createDocumentFragment();
            frag.append(h("span", { className: "pred-logic" }, "NOT "), renderPredicate(pred.predicate));
            return frag;
        }
        default:
            return document.createTextNode(JSON.stringify(pred));
    }
}

function badgeClass(r) {
    return r.outcome === "fail" ? `fail-${r.severity}` : r.outcome;
}

function renderResultItems(results) {
    const items = [];
    for (const r of results) {
        const hasRule = !!r.predicate;
        const item = h("div", {
            className: "result-item" + (hasRule ? " expandable" : ""),
            onclick: function() { this.classList.toggle("expanded"); },
        },
            h("span", { className: `outcome-badge ${badgeClass(r)}` }, r.outcome === "fail" ? r.severity : r.outcome),
            h("span", { className: "result-name" },
                r.rule_name + " ",
                r.builtin ? h("span", { className: "result-builtin" }, "[builtin]") : null,
            ),
            r.detail ? h("span", { className: "result-detail" }, r.detail) : null,
        );

        if (hasRule) {
            const predView = h("div", { className: "predicate-view" });
            if (r.condition) {
                predView.append(
                    h("span", { className: "pred-logic" }, "when"), " ", renderPredicate(r.condition),
                    document.createElement("br"),
                    h("span", { className: "pred-logic" }, "then"), " ", renderPredicate(r.predicate),
                );
            } else {
                predView.append(renderPredicate(r.predicate));
            }
            item.append(predView);
        }
        items.push(item);
    }
    return items;
}

function toggleSort(col) {
    if (sortColumn === col) {
        sortAsc = !sortAsc;
    } else {
        sortColumn = col;
        sortAsc = true;
    }
    sortTable();
}

function sortTable() {
    const table = document.querySelector("#results-content table");
    if (!table || !lastEvalData) return;

    const tbody = table.querySelector("tbody");
    const yamlById = {};
    for (const y of lastEvalData.yamls) yamlById[y.yaml_id] = y;

    const rows = Array.from(tbody.querySelectorAll("tr[data-yaml-id]"));
    rows.sort((a, b) => {
        const ya = yamlById[a.dataset.yamlId];
        const yb = yamlById[b.dataset.yamlId];
        if (!ya || !yb) return 0;
        return compareYamls(ya, yb);
    });
    for (const row of rows) tbody.appendChild(row);

    for (const th of table.querySelectorAll("th.sortable")) {
        const arrow = th.querySelector(".sort-arrow");
        if (arrow) arrow.remove();
        if (th.dataset.sortCol === sortColumn) {
            th.append(h("span", { className: "sort-arrow" }, sortAsc ? '\u25B2' : '\u25BC'));
        }
    }
}

function compareYamls(a, b) {
    const va = getSortValue(a, sortColumn);
    const vb = getSortValue(b, sortColumn);
    const cmp = typeof va === "number" ? va - vb : va < vb ? -1 : va > vb ? 1 : 0;
    return sortAsc ? cmp : -cmp;
}

function getSortValue(yaml, col) {
    switch (col) {
        case "player": return yaml.player_name.toLowerCase();
        case "discord": return yaml.discord_handle.toLowerCase();
        case "game": return yaml.game.toLowerCase();
        case "issues": {
            const c = countBySeverity(yaml.results);
            return c.error * 10000 + c.warning * 100 + c.info;
        }
        case "status": {
            const st = reviewStatuses[yaml.yaml_id] || { status: "unreviewed" };
            const order = { nok: 0, unreviewed: 1, reported: 2, ok: 3 };
            return order[st.status] ?? 1;
        }
        case "created": return yaml.created_at || "";
        default: return 0;
    }
}

function renderResults(data) {
    const content = document.getElementById("results-content");
    if (!data.yamls || data.yamls.length === 0) {
        content.replaceChildren(h("p", null, "No YAMLs in this room."));
        return;
    }

    const sorted = [...data.yamls];
    if (sortColumn) {
        sorted.sort(compareYamls);
    }

    const thead = h("thead", null,
        h("tr", null, ...SORT_COLUMNS.map(([col, label]) => {
            const th = h("th", { className: "sortable", "data-sort-col": col, onclick: () => toggleSort(col) }, label);
            if (col === sortColumn) {
                th.append(h("span", { className: "sort-arrow" }, sortAsc ? '\u25B2' : '\u25BC'));
            }
            return th;
        })),
    );

    const tbody = h("tbody", null);
    for (const yaml of sorted) {
        const counts = countBySeverity(yaml.results);
        const playerCell = h("td", null, yaml.player_name);
        if (yaml.last_edited_by_name) {
            playerCell.append(" ", h("span", { className: "edited-badge", title: `Edited by ${yaml.last_edited_by_name}` }, "edited"));
        }
        const failedRules = yaml.results.filter(r => r.outcome === "fail").map(r => r.rule_name);
        tbody.append(h("tr", { "data-yaml-id": yaml.yaml_id, "data-game": yaml.game, "data-rules": failedRules.join(",") },
            playerCell,
            h("td", null, "@" + yaml.discord_handle),
            h("td", null, yaml.game),
            h("td", { className: "issues" },
                h("span", { className: "has-errors" }, String(counts.error)),
                " / ",
                h("span", { className: "has-warnings" }, String(counts.warning)),
                " / ",
                h("span", { className: "has-info" }, String(counts.info)),
            ),
            h("td", { className: "status-cell" }, renderStatusSelect(yaml.yaml_id)),
            h("td", { className: "date-cell" }, formatDate(yaml.created_at)),
        ));
    }

    content.replaceChildren(h("table", null, thead, tbody));

    tbody.addEventListener("click", (e) => {
        if (e.target.closest(".status-select")) return;
        const row = e.target.closest("tr[data-yaml-id]");
        if (row) showYamlModal(row.dataset.yamlId);
    });

    const games = [...new Set(data.yamls.map(y => gameFilterKey(y.game)))].sort();
    const gf = document.getElementById("game-filter");
    gf.replaceChildren(
        h("option", { value: "" }, "All games"),
        ...games.map(g => h("option", { value: g, selected: gameFilter === g }, g)),
    );
    gf.classList.remove("hidden");

    const ruleNames = [...new Set(data.yamls.flatMap(y => y.results.filter(r => r.outcome === "fail").map(r => r.rule_name)))].sort();
    const rf = document.getElementById("rule-filter");
    rf.value = ruleFilter;
    rf.classList.toggle("hidden", ruleNames.length === 0);
    const dl = document.getElementById("rule-filter-list");
    dl.replaceChildren(...ruleNames.map(r => h("option", { value: r })));

    const sf = document.getElementById("status-filter");
    sf.replaceChildren(
        h("option", { value: "" }, "All statuses"),
        ...STATUS_TYPES.map(([val, label]) => h("option", { value: val, selected: statusFilter === val }, label)),
    );
    sf.classList.remove("hidden");

    applyFilters();
}

function gameFilterKey(game) {
    return game.startsWith("Random (") ? "Random" : game;
}

function applyFilters() {
    const rows = document.querySelectorAll("#results-content tbody tr[data-yaml-id]");
    for (const row of rows) {
        const matchGame = !gameFilter || gameFilterKey(row.dataset.game) === gameFilter;
        const rf = ruleFilter.toLowerCase();
        const matchRule = !rf || (row.dataset.rules && row.dataset.rules.toLowerCase().split(",").some(r => r.includes(rf)));
        const matchStatus = !statusFilter || (reviewStatuses[row.dataset.yamlId] || { status: "unreviewed" }).status === statusFilter;
        row.style.display = (matchGame && matchRule && matchStatus) ? "" : "none";
    }
}

function renderStatusSelect(yamlId, extraClass) {
    const st = reviewStatuses[yamlId] || { status: "unreviewed" };
    const title = st.changed_by_name ? `${st.changed_by_name} on ${new Date(st.changed_at).toLocaleString()}` : "";
    const cls = `status-select status-${st.status}${extraClass ? ` ${extraClass}` : ""}`;
    const sel = selectEl(cls, STATUS_TYPES, st.status);
    if (title) sel.title = title;
    sel.dataset.yamlId = yamlId;
    sel.onchange = function() { onStatusChange(this); };
    return sel;
}

function countBySeverity(results) {
    const counts = { error: 0, warning: 0, info: 0 };
    for (const r of results) {
        if (counts[r.severity] !== undefined) {
            counts[r.severity]++;
        }
    }
    return counts;
}


async function showYamlModal(yamlId) {
    if (!lastEvalData) return;
    const yaml = lastEvalData.yamls.find(y => y.yaml_id === yamlId);
    if (!yaml) return;

    currentModalYamlId = yamlId;

    const mc = document.getElementById("yaml-modal-content");
    const codeEl = h("code", { className: "language-yaml" }, "Loading...");
    const viewerDiv = h("div", { className: "yaml-viewer" }, h("pre", null, codeEl));

    const titleActions = [];
    if (!IS_LOCKED) {
        titleActions.push(h("button", { className: "small accent", onclick: () => enterEditMode(yamlId) }, "Edit"));
        titleActions.push(h("button", { className: "small danger", onclick: () => confirmDeleteYaml(yamlId) }, "Delete"));
    }

    mc.replaceChildren(
        h("h3", null,
            yaml.player_name + " ",
            renderStatusSelect(yaml.yaml_id, "status-modal"),
            ...titleActions,
        ),
        h("div", { className: "subtitle" }, yaml.game + " - @" + yaml.discord_handle),
        ...renderResultItems(yaml.results),
        viewerDiv,
    );

    const yamlUrl = `${LOBBY_ROOT_URL}/api/room/${ROOM_ID}/download/${yaml.yaml_id}`;
    const buttons = [
        h("a", { href: yamlUrl, target: "_blank", className: "button" }, "Download"),
    ];
    buttons.push(h("button", { onclick: hideYamlModal }, "Close"));
    document.getElementById("yaml-modal-buttons").replaceChildren(...buttons);
    const dialog = document.getElementById("yaml-modal");
    if (!dialog.open) dialog.showModal();

    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/yaml/${yamlId}`);
        if (!resp.ok) throw new Error(resp.statusText);
        const data = await resp.json();
        yamlDetailCache[yamlId] = data;

        const displayContent = data.edited_content || data.content || "";
        codeEl.textContent = displayContent;
        hljs.highlightElement(codeEl);

        if (data.edited_content) {
            const editInfo = h("div", { className: "edit-info-bar" },
                h("span", { className: "edited-badge" }, "edited"),
                data.last_edited_by_name ? ` by ${data.last_edited_by_name}` : "",
                data.last_edited_at ? ` on ${formatDate(data.last_edited_at)}` : "",
                " ",
                h("button", { className: "small", onclick: () => toggleOriginal(yamlId) }, "View original"),
            );
            viewerDiv.before(editInfo);
        }
    } catch (e) {
        codeEl.textContent = "Failed to load YAML content. Maybe it got removed?";
    }
}

function toggleOriginal(yamlId) {
    const data = yamlDetailCache[yamlId];
    if (!data || !data.edited_content) return;

    const mc = document.getElementById("yaml-modal-content");
    const viewer = mc.querySelector(".yaml-viewer");
    const oldCode = viewer.querySelector("code");
    const infoBar = mc.querySelector(".edit-info-bar");
    const toggleBtn = infoBar.querySelector("button");

    const showingOriginal = toggleBtn.textContent === "View current";
    const content = showingOriginal ? data.edited_content : data.content;
    toggleBtn.textContent = showingOriginal ? "View original" : "View current";

    const newCode = h("code", { className: "language-yaml" }, content);
    oldCode.replaceWith(newCode);
    hljs.highlightElement(newCode);
}

function enterEditMode(yamlId) {
    const data = yamlDetailCache[yamlId];
    if (!data) { showToast("YAML content not loaded yet"); return; }

    const mc = document.getElementById("yaml-modal-content");
    const viewer = mc.querySelector(".yaml-viewer");
    const infoBar = mc.querySelector(".edit-info-bar");

    const currentContent = data.edited_content || data.content || "";
    const textarea = h("textarea", { className: "yaml-edit-textarea", spellcheck: false }, currentContent);
    const errorDiv = h("div", { className: "edit-error hidden" });

    const editContainer = h("div", { className: "yaml-edit-container" }, textarea, errorDiv);

    if (infoBar) infoBar.classList.add("hidden");
    viewer.replaceWith(editContainer);

    document.getElementById("yaml-modal-buttons").replaceChildren(
        h("button", { className: "primary", onclick: () => saveEdit(yamlId, textarea, errorDiv) }, "Save"),
        h("button", { onclick: () => cancelEdit(yamlId) }, "Cancel"),
    );
}

async function saveEdit(yamlId, textarea, errorDiv) {
    const content = textarea.value;
    const saveBtn = document.querySelector("#yaml-modal-buttons .primary");
    if (saveBtn) saveBtn.disabled = true;
    errorDiv.classList.add("hidden");

    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/yaml/${yamlId}/edit`, {
            method: "PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ content }),
        });

        if (!resp.ok) {
            const text = await resp.text();
            let msg = "Save failed";
            try { msg = JSON.parse(text)?.error || text || msg; } catch { msg = text || msg; }
            errorDiv.textContent = msg;
            errorDiv.classList.remove("hidden");
            return;
        }

        showToast("YAML saved successfully", "info");

        delete yamlDetailCache[yamlId];
        await runEvaluation();
        showYamlModal(yamlId);
    } catch (e) {
        errorDiv.textContent = "Network error: " + e.message;
        errorDiv.classList.remove("hidden");
    } finally {
        if (saveBtn) saveBtn.disabled = false;
    }
}

function cancelEdit(yamlId) {
    showYamlModal(yamlId);
}

function hideYamlModal() {
    document.getElementById("yaml-modal").close();
}

function confirmDeleteYaml(yamlId) {
    const yaml = lastEvalData.yamls.find(y => y.yaml_id === yamlId);
    if (!yaml) return;

    const mc = document.getElementById("yaml-modal-content");
    const confirmInput = h("input", { type: "text", placeholder: yaml.player_name, autocomplete: "off" });
    const errorDiv = h("div", { className: "edit-error hidden" });
    const deleteBtn = h("button", { className: "danger", disabled: true, onclick: () => deleteYaml(yamlId, errorDiv) }, "Confirm delete");

    confirmInput.oninput = () => {
        deleteBtn.disabled = confirmInput.value !== yaml.player_name;
    };

    mc.replaceChildren(
        h("h3", null, "Delete YAML"),
        h("p", null, `Type "${yaml.player_name}" to confirm deletion of this YAML.`),
        confirmInput,
        errorDiv,
    );

    document.getElementById("yaml-modal-buttons").replaceChildren(
        deleteBtn,
        h("button", { onclick: () => showYamlModal(yamlId) }, "Cancel"),
    );
}

async function deleteYaml(yamlId, errorDiv) {
    errorDiv.classList.add("hidden");
    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/yaml/${yamlId}`, { method: "DELETE" });
        const text = await resp.text();
        if (!resp.ok) {
            errorDiv.textContent = text;
            errorDiv.classList.remove("hidden");
            return;
        }
        hideYamlModal();
        const row = document.querySelector(`tr[data-yaml-id="${yamlId}"]`);
        if (row) row.remove();
        if (lastEvalData) {
            lastEvalData.yamls = lastEvalData.yamls.filter(y => y.yaml_id !== yamlId);
        }
        showToast("YAML deleted", "info");
    } catch (e) {
        errorDiv.textContent = "Network error: " + e.message;
        errorDiv.classList.remove("hidden");
    }
}

async function fetchReviewStatuses() {
    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/statuses`);
        if (!resp.ok) { showToast("Failed to load review statuses"); return; }
        const statuses = await resp.json();
        reviewStatuses = {};
        for (const s of statuses) {
            reviewStatuses[s.yaml_id] = s;
        }
    } catch(e) { showToast("Failed to load review statuses: " + e.message); }
}

async function onStatusChange(sel) {
    const yamlId = sel.dataset.yamlId;
    const status = sel.value;

    const allSelects = document.querySelectorAll(`select[data-yaml-id="${yamlId}"]`);
    for (const s of allSelects) s.disabled = true;

    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/status/${yamlId}`, {
            method: "PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ status }),
        });

        if (!resp.ok) {
            showToast("Failed to update status: " + await resp.text());
            return;
        }

        const result = await resp.json();
        reviewStatuses[yamlId] = result;

        const title = result.changed_by_name ? `${result.changed_by_name} on ${new Date(result.changed_at).toLocaleString()}` : "";
        for (const s of allSelects) {
            s.value = status;
            for (const [st] of STATUS_TYPES) s.classList.remove(`status-${st}`);
            s.classList.add(`status-${status}`);
            s.title = title;
        }
        applyFilters();
    } finally {
        for (const s of allSelects) s.disabled = false;
    }
}

document.getElementById("yaml-modal").addEventListener("close", () => {
    currentModalYamlId = null;
});

refreshPresetList().then(() => {
    if (ASSIGNED_PRESET_ID) {
        runEvaluation();
    }
});
</script>
</body>
</html>
