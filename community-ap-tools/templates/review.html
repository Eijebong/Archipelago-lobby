<html>
<head>
    <title>YAML Review - {{ room_name }}</title>
    <link rel="stylesheet" href="/static/review.css?{{ static_version }}">
    <link rel="stylesheet" href="/static/contrib/highlight.js/monokai.min.css?{{ static_version }}">
    <script src="/static/contrib/highlight.js/highlight.min.js?{{ static_version }}" defer></script>
    <script src="/static/contrib/highlight.js/yaml.min.js?{{ static_version }}" defer></script>
</head>
<body>
    <h1>YAML Review: {{ room_name }}</h1>

    <div class="section">
        <h2>Preset</h2>
        <div class="inline-form">
            <select id="preset-select" onchange="onPresetChange()">
                <option value="">-- No preset --</option>
            </select>
            <button id="edit-preset-btn" class="hidden" onclick="window.location.href=this.dataset.href">Edit preset</button>
        </div>
    </div>

    <div class="section" id="results-area">
        <div class="inline-form" style="margin-bottom:0.5em"><h2 style="margin:0">Results</h2><select id="game-filter" class="hidden" onchange="applyGameFilter(this.value)"><option value="">All games</option></select></div>
        <div id="results-content">
            <p class="loading">Select a preset and evaluate, or wait for auto-evaluation...</p>
        </div>
    </div>

    <div class="modal-backdrop" id="yaml-modal" onclick="if (event.target === this) hideYamlModal()">
        <div class="modal">

            <div class="modal-body" id="yaml-modal-content"></div>
            <div class="button-container" id="yaml-modal-buttons"></div>
        </div>
    </div>

<script src="/static/review-utils.js?{{ static_version }}"></script>
<script>
const ROOM_ID = "{{ room_id }}";
const LOBBY_ROOT_URL = "{{ lobby_root_url }}".replace(/\/$/, "");
const ASSIGNED_PRESET_ID = {% match assigned_preset_id %}{% when Some with (id) %}{{ id }}{% when None %}null{% endmatch %};

const CHECK_LABELS = {
    truthy: "is truthy", not_truthy: "is not truthy", equals: "equals", not_equals: "does not equal",
    greater_than: ">", less_than: "<", range: "between",
    regex: "matches", contains: "contains", exists: "exists", not_exists: "does not exist",
};

const STATUS_TYPES = [["unreviewed", "Unreviewed"], ["reported", "Reported"], ["nok", "NOK"], ["ok", "OK"]];

const SORT_COLUMNS = [
    ["player", "Player"], ["discord", "Discord"], ["game", "Game"],
    ["issues", "Issues"], ["status", "Status"], ["created", "Created"],
];

let lastEvalData = null;
let reviewStatuses = {};
let sortColumn = "status";
let sortAsc = true;
let gameFilter = "";

async function refreshPresetList() {
    const resp = await fetch("/api/presets");
    if (!resp.ok) { showToast("Failed to load presets"); return; }
    const presets = await resp.json();
    const sel = document.getElementById("preset-select");
    sel.replaceChildren(
        h("option", { value: "" }, "-- No preset --"),
        ...presets.map(p => h("option", { value: p.id }, p.name)),
    );
    if (ASSIGNED_PRESET_ID) {
        sel.value = ASSIGNED_PRESET_ID;
    }
    updateEditLink();
}

function updateEditLink() {
    const sel = document.getElementById("preset-select");
    const btn = document.getElementById("edit-preset-btn");
    const presetId = parseInt(sel.value);
    if (presetId) {
        btn.dataset.href = `/presets/${presetId}?from_room=${ROOM_ID}`;
        btn.classList.remove("hidden");
    } else {
        btn.classList.add("hidden");
    }
}

async function onPresetChange() {
    const sel = document.getElementById("preset-select");
    const presetId = parseInt(sel.value);
    updateEditLink();

    if (!presetId) {
        await fetch(`/api/room/${ROOM_ID}/preset`, { method: "DELETE" });
        document.getElementById("results-content").replaceChildren(h("p", null, "No preset assigned."));
        lastEvalData = null;
        return;
    }

    const resp = await fetch(`/api/room/${ROOM_ID}/preset`, {
        method: "PUT",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ preset_id: presetId }),
    });
    if (!resp.ok) { showToast("Failed to assign preset"); return; }
    runEvaluation();
}

async function runEvaluation() {
    const sel = document.getElementById("preset-select");
    const presetId = parseInt(sel.value);
    const content = document.getElementById("results-content");
    if (!presetId) {
        content.replaceChildren(h("p", null, "No preset assigned."));
        return;
    }

    content.replaceChildren(h("p", { className: "loading" }, "Evaluating..."));

    const resp = await fetch(`/api/review/${ROOM_ID}/evaluate`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ preset_id: presetId }),
    });

    if (!resp.ok) {
        content.replaceChildren(h("p", { className: "error-text" }, "Error: " + await resp.text()));
        return;
    }

    const data = await resp.json();
    lastEvalData = data;
    await fetchReviewStatuses();
    renderResults(data);
}

function formatDate(s) {
    if (!s) return "";
    const d = new Date(s);
    if (isNaN(d)) return s;
    return d.toLocaleDateString() + " " + d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
}

function renderCheck(path, check) {
    const op = CHECK_LABELS[check.type] || check.type;
    const v = (s) => h("span", { className: "pred-value" }, String(s));
    const frag = document.createDocumentFragment();
    frag.append(h("span", { className: "pred-path" }, path), " ", h("span", { className: "pred-op" }, op));

    switch (check.type) {
        case "equals": case "not_equals": case "greater_than": case "less_than":
        case "regex": case "contains": {
            const val = check.type === "regex" ? '/' + check.pattern + '/' : String(check.value);
            frag.append(" ", v(val));
            break;
        }
        case "range":
            frag.append(" ", v(check.min), " ", h("span", { className: "pred-op" }, "and"), " ", v(check.max));
            break;
    }
    return frag;
}

function renderPredicate(pred) {
    switch (pred.type) {
        case "check":
            return renderCheck(pred.path, pred.check);
        case "and":
        case "or": {
            const frag = document.createDocumentFragment();
            pred.predicates.forEach((p, i) => {
                if (i > 0) frag.append(document.createElement("br"), h("span", { className: "pred-logic" }, pred.type.toUpperCase() + " "));
                frag.append(renderPredicate(p));
            });
            return frag;
        }
        case "not": {
            const frag = document.createDocumentFragment();
            frag.append(h("span", { className: "pred-logic" }, "NOT "), renderPredicate(pred.predicate));
            return frag;
        }
        default:
            return document.createTextNode(JSON.stringify(pred));
    }
}

function badgeClass(r) {
    return r.outcome === "fail" ? `fail-${r.severity}` : r.outcome;
}

function renderResultItems(results) {
    const items = [];
    for (const r of results) {
        const hasRule = !!r.predicate;
        const item = h("div", {
            className: "result-item" + (hasRule ? " expandable" : ""),
            onclick: function() { this.classList.toggle("expanded"); },
        },
            h("span", { className: `outcome-badge ${badgeClass(r)}` }, r.outcome === "fail" ? r.severity : r.outcome),
            h("span", { className: "result-name" },
                r.rule_name + " ",
                r.builtin ? h("span", { className: "result-builtin" }, "[builtin]") : null,
            ),
            r.detail ? h("span", { className: "result-detail" }, r.detail) : null,
        );

        if (hasRule) {
            const predView = h("div", { className: "predicate-view" });
            if (r.condition) {
                predView.append(
                    h("span", { className: "pred-logic" }, "when"), " ", renderPredicate(r.condition),
                    document.createElement("br"),
                    h("span", { className: "pred-logic" }, "then"), " ", renderPredicate(r.predicate),
                );
            } else {
                predView.append(renderPredicate(r.predicate));
            }
            item.append(predView);
        }
        items.push(item);
    }
    return items;
}

function toggleSort(col) {
    if (sortColumn === col) {
        sortAsc = !sortAsc;
    } else {
        sortColumn = col;
        sortAsc = true;
    }
    sortTable();
}

function sortTable() {
    const table = document.querySelector("#results-content table");
    if (!table || !lastEvalData) return;

    const tbody = table.querySelector("tbody");
    const yamlById = {};
    for (const y of lastEvalData.yamls) yamlById[y.yaml_id] = y;

    const rows = Array.from(tbody.querySelectorAll("tr[data-yaml-id]"));
    rows.sort((a, b) => {
        const ya = yamlById[a.dataset.yamlId];
        const yb = yamlById[b.dataset.yamlId];
        if (!ya || !yb) return 0;
        return compareYamls(ya, yb);
    });
    for (const row of rows) tbody.appendChild(row);

    for (const th of table.querySelectorAll("th.sortable")) {
        const arrow = th.querySelector(".sort-arrow");
        if (arrow) arrow.remove();
        if (th.dataset.sortCol === sortColumn) {
            th.append(h("span", { className: "sort-arrow" }, sortAsc ? '\u25B2' : '\u25BC'));
        }
    }
}

function compareYamls(a, b) {
    const va = getSortValue(a, sortColumn);
    const vb = getSortValue(b, sortColumn);
    const cmp = typeof va === "number" ? va - vb : va < vb ? -1 : va > vb ? 1 : 0;
    return sortAsc ? cmp : -cmp;
}

function getSortValue(yaml, col) {
    switch (col) {
        case "player": return yaml.player_name.toLowerCase();
        case "discord": return yaml.discord_handle.toLowerCase();
        case "game": return yaml.game.toLowerCase();
        case "issues": {
            const c = countBySeverity(yaml.results);
            return c.error * 10000 + c.warning * 100 + c.info;
        }
        case "status": {
            const st = reviewStatuses[yaml.yaml_id] || { status: "unreviewed" };
            const order = { nok: 0, unreviewed: 1, reported: 2, ok: 3 };
            return order[st.status] ?? 1;
        }
        case "created": return yaml.created_at || "";
        default: return 0;
    }
}

function renderResults(data) {
    const content = document.getElementById("results-content");
    if (!data.yamls || data.yamls.length === 0) {
        content.replaceChildren(h("p", null, "No YAMLs in this room."));
        return;
    }

    const sorted = [...data.yamls];
    if (sortColumn) {
        sorted.sort(compareYamls);
    }

    const thead = h("thead", null,
        h("tr", null, ...SORT_COLUMNS.map(([col, label]) => {
            const th = h("th", { className: "sortable", "data-sort-col": col, onclick: () => toggleSort(col) }, label);
            if (col === sortColumn) {
                th.append(h("span", { className: "sort-arrow" }, sortAsc ? '\u25B2' : '\u25BC'));
            }
            return th;
        })),
    );

    const tbody = h("tbody", null);
    for (const yaml of sorted) {
        const counts = countBySeverity(yaml.results);
        tbody.append(h("tr", { "data-yaml-id": yaml.yaml_id, "data-game": yaml.game },
            h("td", null, yaml.player_name),
            h("td", null, "@" + yaml.discord_handle),
            h("td", null, yaml.game),
            h("td", { className: "issues" },
                h("span", { className: "has-errors" }, String(counts.error)),
                " / ",
                h("span", { className: "has-warnings" }, String(counts.warning)),
                " / ",
                h("span", { className: "has-info" }, String(counts.info)),
            ),
            h("td", { className: "status-cell" }, renderStatusSelect(yaml.yaml_id)),
            h("td", { className: "date-cell" }, formatDate(yaml.created_at)),
        ));
    }

    content.replaceChildren(h("table", null, thead, tbody));

    tbody.addEventListener("click", (e) => {
        if (e.target.closest(".status-select")) return;
        const row = e.target.closest("tr[data-yaml-id]");
        if (row) showYamlModal(row.dataset.yamlId);
    });

    const games = [...new Set(data.yamls.map(y => y.game))].sort();
    const gf = document.getElementById("game-filter");
    gf.replaceChildren(
        h("option", { value: "" }, "All games"),
        ...games.map(g => h("option", { value: g, selected: gameFilter === g }, g)),
    );
    gf.classList.remove("hidden");
    applyGameFilter(gameFilter);
}

function applyGameFilter(game) {
    gameFilter = game;
    const rows = document.querySelectorAll("#results-content tbody tr[data-yaml-id]");
    for (const row of rows) {
        row.style.display = (!game || row.dataset.game === game) ? "" : "none";
    }
}

function renderStatusSelect(yamlId, extraClass) {
    const st = reviewStatuses[yamlId] || { status: "unreviewed" };
    const title = st.changed_by_name ? `${st.changed_by_name} on ${new Date(st.changed_at).toLocaleString()}` : "";
    const cls = `status-select status-${st.status}${extraClass ? ` ${extraClass}` : ""}`;
    const sel = selectEl(cls, STATUS_TYPES, st.status);
    if (title) sel.title = title;
    sel.dataset.yamlId = yamlId;
    sel.onchange = function() { onStatusChange(this); };
    return sel;
}

function countBySeverity(results) {
    const counts = { error: 0, warning: 0, info: 0 };
    for (const r of results) {
        if (counts[r.severity] !== undefined) {
            counts[r.severity]++;
        }
    }
    return counts;
}


async function showYamlModal(yamlId) {
    if (!lastEvalData) return;
    const yaml = lastEvalData.yamls.find(y => y.yaml_id === yamlId);
    if (!yaml) return;

    const mc = document.getElementById("yaml-modal-content");
    const codeEl = h("code", { className: "language-yaml" }, "Loading...");

    mc.replaceChildren(
        h("h3", null, yaml.player_name + " ", renderStatusSelect(yaml.yaml_id, "status-modal")),
        h("div", { className: "subtitle" }, yaml.game),
        ...renderResultItems(yaml.results),
        h("div", { className: "yaml-viewer" }, h("pre", null, codeEl)),
    );

    const yamlUrl = `${LOBBY_ROOT_URL}/api/room/${ROOM_ID}/download/${yaml.yaml_id}`;
    document.getElementById("yaml-modal-buttons").replaceChildren(
        h("a", { href: yamlUrl, target: "_blank", className: "button" }, "Download"),
        h("button", { onclick: hideYamlModal }, "Close"),
    );
    document.getElementById("yaml-modal").classList.add("open");

    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/yaml/${yamlId}`);
        if (!resp.ok) throw new Error(resp.statusText);
        const data = await resp.json();
        codeEl.textContent = data.content || "";
        hljs.highlightElement(codeEl);
    } catch (e) {
        codeEl.textContent = "Failed to load YAML content. Maybe it got removed?";
    }
}

function hideYamlModal() {
    document.getElementById("yaml-modal").classList.remove("open");
}

async function fetchReviewStatuses() {
    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/statuses`);
        if (!resp.ok) { showToast("Failed to load review statuses"); return; }
        const statuses = await resp.json();
        reviewStatuses = {};
        for (const s of statuses) {
            reviewStatuses[s.yaml_id] = s;
        }
    } catch(e) { showToast("Failed to load review statuses: " + e.message); }
}

async function onStatusChange(sel) {
    const yamlId = sel.dataset.yamlId;
    const status = sel.value;

    const allSelects = document.querySelectorAll(`select[data-yaml-id="${yamlId}"]`);
    for (const s of allSelects) s.disabled = true;

    try {
        const resp = await fetch(`/api/review/${ROOM_ID}/status/${yamlId}`, {
            method: "PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({ status }),
        });

        if (!resp.ok) {
            showToast("Failed to update status: " + await resp.text());
            return;
        }

        const result = await resp.json();
        reviewStatuses[yamlId] = result;

        const title = result.changed_by_name ? `${result.changed_by_name} on ${new Date(result.changed_at).toLocaleString()}` : "";
        for (const s of allSelects) {
            s.value = status;
            for (const [st] of STATUS_TYPES) s.classList.remove(`status-${st}`);
            s.classList.add(`status-${status}`);
            s.title = title;
        }
    } finally {
        for (const s of allSelects) s.disabled = false;
    }
}

document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") { hideYamlModal(); }
});

refreshPresetList().then(() => {
    if (ASSIGNED_PRESET_ID) {
        runEvaluation();
    }
});
</script>
</body>
</html>
